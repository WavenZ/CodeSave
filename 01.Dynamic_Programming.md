## 1. 动态规划
----

### 1.1 动态规划要素

合适应用动态规划算法求解的最优化问题应该具备的两个要素：**最优子结构**和**子问题重叠**。

**最优子结构**：如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有**最优子结构**。

**子问题重叠**：如果递归算法反复求解相同的子问题，则称该问题具有**重叠子问题**性质。

### 2.2 动态规划实例分析

---

#### 1. Fibnachi

最优子结构：严格来说斐波那契问题没有最优子结构，因为求解斐波那契的过程只是一个递推的过程，只有一个解，因此不存在最优解，也就没有最优子结构。

重叠子问题：斐波那契问题倒是一个典型的重叠子问题的结构，因此常用来介绍动态规划的性质。从下图就可以看出其重叠子问题的性质：

<div align = center>
<img src="https://img-blog.csdnimg.cn/20190407221937264.png" width="60%" >
<div align = left>
	
可以看到，在递归树中，以`3`为根的子树被重复计算了3次，当递归的规模更大时，会有大量的重复计算。
	
	
状态转移方程：`f(n) = f(n - 1) + f(n - 2)`

初始值：`f(0) = 0, f(1) = 1`

因此循环从`i = 2`到`i = n - 1`。

空间的优化：由于`f(n)`仅与`f(n-1)`和`f(n-2)`有关，因此不必用一个完整的dp表来保存子问题的解，这里使用两个变量（`prev`、`curr`）即可。

```c
#include <iostream>
#include <vector>

// Fibonachi
// Dynamic Programming Method
// Time complexity : O(n)
// Space complexity : O(1)

unsigned fib(short n) {
	if (n < 2) return n - 1;
	unsigned prev = 0, curr = 1;
	for (int i = 2; i < n; i++) {
		unsigned sum = prev + curr;
		prev = curr;
		curr = sum;
	}
	return curr;
}

int main(void) {
	for(int i = 1; i <= 10; ++i)
		std::cout << fib(i) << std::endl;
	return 0;
}
```
---

#### 2. CoinChange ([LeeCode 322](https://leetcode.com/problems/coin-change/)) **  

**最优子结构：**

假设硬币有`{1， 2， 5}`三种，需要换的钱为`amount`。

目标是将`amount`换成以三种硬币，要求总的硬币个数最少。

设将`amount`换成硬币的最少个数为`f(amount)`，则`f(amount) = 1 + min(f(amount - 1), f(amount - 2), f(amount - 5)`。

求解原问题`f(amount)`则必须求的三个子最优解：`f(amount - 1)`、`f(amount - 2)`、`f(amount - 6)`，满足最优子结构性质。

**重叠子问题：**

原问题的子问题为：`f(amount - 1)`、`f(amount - 2)`、`f(amount - 5)`

显然`f(amount - 1)`又有子问题`f(amount - 2)`、`f(amount - 3)`、`f(amount - 2)`，满足子问题重叠性质。

**状态转移方程：** `f(n) = 1 + min(f(n - ci))`，ci为第i种硬币的值。

**初始值：** `f(0) = 0`（money = 0时，可换硬币的数量为0）

循环从`i = 1`到`i = amount`，表示自底向上计算`amount`所能兑换的最少的硬币数。

```c
class Solution {
public:
	int coinChange(vector<int>& coins, int amount) {
		vector<int> dp(amount + 1, INT32_MAX - 1);
		dp[0] = 0;
		for (int i = 1; i <= amount; i++) {
			for (int coin : coins) {
				if (i - coin >= 0) dp[i] = min(dp[i], 1 + dp[i - coin]);
			}
		}
		return dp[amount] == INT32_MAX - 1 ? -1 : dp[amount];
	}
};
```
Runtime: 44 ms, faster than 76.58% of C++ online submissions for Coin Change.<br>
Memory Usage: 12.5 MB, less than 88.24% of C++ online submissions for Coin Change.



**3. Cut** 算法导论例题 **

**最优子结构：** 

设长度为`len`，`c[i]`为某一段的长度，`p[i]`是对应的价格，目标是找到一个切割方案，使得总的价格达到最大。

设将长度为`len`的钢条切割得到的最大总价为`f(len)`，则`f(len) = max(p[i] + f(len - c[i])`，其中`i = 0 .. k-1`。

因此，要求解问题`f(len)`，需求解子问题`f(len - c[i]), i = 0 .. k-1`，满足最优子结构。

**重叠子问题：**

原问题`f(len)`的子问题为`f(len - c[i])`，显然满足子问题重叠。

**状态转移方程：** `f(n) = max(p[i] + f(n-c[i]))`，其中，`c[i]`为一段的长度，`p[i]`为对应的价格

**初始值：** `f(0) = 0`

循环从`i = 1`到`i = n`结束，表示自底向上计算长度为n的钢条的最佳切割方案。

空间的优化：由于`f(n)`与`f(n-ci)`有关，ci的取值过多，不值得用时间来换空间，因此此处直接用一个长度为`n + 1`的dp表即可。

```c
#include <iostream>
#include <vector>
#include <algorithm>

// Cut
// Dynamic Programming Method
// Time Complexity : O(n)
// Space Complexity : O(n)

int Cut(const std::vector<int> prices, int len, std::vector<int> &answer) {
	std::vector<int> dp(len + 1, - 1);
	dp[0] = 0;
	for (int i = 1; i <= len; ++i) {
		for (int j = 1; j <= 10; ++j) {
			if (i - j < 0) continue;
			if (prices[j - 1] + dp[i - j] > dp[i]) {
				dp[i] = prices[j - 1] + dp[i - j];
				answer[i] = j;
			}
		}
	}
	return dp[len];
}

int main(void) {
	std::vector<int> prices = { 1, 5, 8, 9, 10, 17, 17, 20, 24, 30 };
	std::vector<int> answer(33 + 1, 0);
	std::cout << Cut(prices, 33, answer) << std::endl;
	int len = 33;
	while (len) {
		std::cout << answer[len] << " ";
		len = len - answer[len];
	}
	std::cout << std::endl;
	return 0;
}
```
**4. Best Time to Buy and Sell Stock** [LeeCode121](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) ***

这个题虽然LeeCode标记为了动态规划问题，但实际上这道题并不满足动态规划所需的两个要素中的子问题重叠特性。

比较简单的方法是利用两个变量来保存最小值和最大利润，通过一次遍历即可求得最大利润：
```c
class Solution{
    // One Pass Solution
    int maxProfit(vector<int>& prices) {
        if(prices.size() < 2) return 0;
        int max_profit = 0, min_elem = INT32_MAX;
        for(int i = 0; i < prices.size(); ++i){
            if(prices[i] < min_elem){	// 更新最小值
                min_elem = prices[i];
            }else{
                max_profit = max(max_profit, prices[i] - min_elem); // 更新最大利润
            }
        }
        return max_profit;
    }
}
```
Runtime: 8 ms, faster than 66.27% of C++ online submissions for Best Time to Buy and Sell Stock.<br>
Memory Usage: 9.6 MB, less than 80.73% of C++ online submissions for Best Time to Buy and Sell Stock.

前面说到，这个题没有子问题重叠特性，但是也可以发掘出**最优子结构**特性：

假设`f(i)`是第`i`时刻买入时能获得的最大利润，如果`f(i + 1) > 0`，则`f(i) = price[i + 1] - price[i] + f(i + 1)`，否则`f(i) = price[i + 1] - price[i]`。

因此，原问题的最优解`f(i)`与子问题的最优解`f(i + 1)` 有关，满足最佳子结构特性。可以用动态规划来做，但由于不满足子问题重叠的特性，因此动态规划的性能并不优于递归方式或者上面的One Pass Solution。
```c
class Solution{
    int maxProfit(vector<int>& prices) {
        if (prices.size() < 2) return 0;
        vector<int> dp(prices.size(), 0);
        for (int i = prices.size() - 2; i >= 0; --i) {
            int profit = prices[i + 1] - prices[i];
            if (dp[i + 1] > 0)
                profit += dp[i + 1];
            dp[i] = profit;
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```
**5. climbing-stairs** [LeeCode70](https://leetcode.com/problems/climbing-stairs/) *

这个问题实际上就是斐波那契问题。

最优子结构：加入`i`阶梯子有`f(i)`种走法，那么`f(i) = f(i - 1) + f(i - 2)`，其中`i > 1`。

class Solution {
public:
    /*
    int climbStairs(int n) {
        if(n == 0) return 1;
        int prev = 1, curr = 1;
        int sum = 1;
        for(int i = 2; i <= n; ++i){
            sum = prev + curr;
            prev = curr;
            curr = sum;
        }
        return sum;
    }
    */
    int climbStairs(int n){
        vector<int> dp(n + 1, 1);
        for(int i = 2; i <= n; ++i){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};


```c
class Solution {
public:
    int climbStairs(int n) {
        if(n == 0) return 1;
        int prev = 1, curr = 1;
        int sum = 1;
        for(int i = 2; i <= n; ++i){
            sum = prev + curr;
            prev = curr;
            curr = sum;
        }
        return sum;
    }
};
```
**6. house-robber** **
```c

状态转移方程：`f(i) = max(f(i + 2) + ci[i], f(i + 3) + ci[i + 1])`，其中`ci[i]`为第i户的钱财。


class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];
        vector<int> dp(nums.size() + 1, 0);
        dp[nums.size()] = 0;
        dp[nums.size() - 1] = nums[nums.size() - 1];
        dp[nums.size() - 2] = std::max(nums[nums.size() - 1], nums[nums.size() - 2]);
        for(int i = nums.size() - 3; i >= 0; --i){
            dp[i] = std::max(dp[i + 2] + nums[i], dp[i + 3] + nums[i + 1]);
        }
        return dp[0];
    }
};
```

**7. stone_game** ***

假设dp为比对手多得的分数，由于这里可能从数组头也可能从数组尾取数据，因此用二维数组来作为dp表格。其中第一行表示长度为d的子数组的最优解，也就是在长度为d的子数组中可能得到的比对方多的分数。

例如：对于`5, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9`

玩家与对手所得分数的差值的最大值为：`f(0..10) = max(5 - f(1..10), 9 - f(0..9))`

其中，`f(0..10)`表示玩家与对手的最大分差。`f(1..10)`表示玩家取走第一个元素`5`时，对手与玩家的分差，而`5-f(1..10)`则表示玩家取走元素`5`时，可能与对手的最大分差。

因此，状态转移方程为：`f(a..b) = max(q[a] - f(a+1..b), q[b] - f(a..b-1))`

写成数组形式为：`dp[a][b] = max(q[a] - dp[a+1][b], q[b] - dp[a][b-1])`

初始值：当`a=b`时，`dp[i][i] = q[i]`。

```c
class Solution {
public:
	bool stoneGame(vector<int>& piles) {
		vector<vector<int>> dp(piles.size(), vector<int>(piles.size(), 0));
		for (size_t i = 0; i < piles.size(); ++i)	// 对角线
			dp[i][i] = piles[i];

		for (size_t d = 1; d < piles.size(); ++d) {
			for (size_t i = 0; i < piles.size() - d; ++i) {
				dp[i][i + d] = max(piles[i] - dp[i + 1][i + d],
					piles[i + d] - dp[i][i + d - 1]);
			}
		}
		return dp[0][piles.size() - 1] > 0;
	}
};
```

**8. minimum-cost-tree-from-leaf-values** ***

状态转移方程：`dp[i][j] = min(dp[i][d] + dp[d + 1][j] + max(arr[i..d]) * max(arr[d+1..j])，d = i, i+1, ..., j-1`

初始值：`dp[i][i] = arr[i]，i = 0..n`, `dp[i][i + 1] = arr[i] * arr[i+1]， i = 0..n-1`

此外，上述方程中的`max(arr[i..d]`也可由dp得到：

状态转移方程：`dp[i][j] = max(dp[i] + dp[i + 1][j])`

初始值：`dp[i][i+1] = max(arr[i], arr[i + 1])`
```c
class Solution {
public:
	int mctFromLeafValues(vector<int>& arr) {
		vector<vector<int>> dp(arr.size(), vector<int>(arr.size(), 0));
		vector<vector<int>> dp_max(arr.size(), vector<int>(arr.size(), 0));
		// 初始值，长度为为2的项
		for (int i = 0; i < arr.size(); ++i) dp_max[i][i] = arr[i];
		for (int i = 0; i < arr.size() - 1; ++i) {
			dp[i][i + 1] = arr[i] * arr[i + 1];
			dp_max[i][i + 1] = max(arr[i], arr[i + 1]);
		}
		for (int d = 2; d < arr.size(); ++d)
			for (int i = 0; i < arr.size() - d; ++i) {
				dp_max[i][i + d] = max(arr[i], dp_max[i + 1][i + d]);
				int mininum = INT32_MAX;
				for (int j = i; j < i + d; ++j) {
					mininum = min(mininum, dp[i][j] + dp[j + 1][i + d] + dp_max[i][j] * dp_max[j + 1][i + d]);
				}
				dp[i][i + d] = mininum;
			}


		return dp[0][arr.size() - 1];
	}
};
```

**9. stone-game-ii** ****

以`2 7 9 4 4`为例

如果m的值大于3，则可取的最多元素个数为6，此时只需要全部取了即为最大值。

如果m的值小于3，例如m的值为1，则可取的元素个数`1 <= x <= 2`，则最优解为`f(1..5) = max(2 + sum(2..5) - f(2..5), 9 + sum(3..5) - f(3..5))`

最优解化简为：`f(1..5) = max(sum(1..5) - f(2..5), sum(2..5) - f(3..5))` = `sum(1..5) - max(f(2..5), f(3..5))`

进一步抽象得到状态转移方程：`dp[i] = sums[i] - max(dp[i + x])`，其中`1 <= x <= 2*m`。

但是其中还包含未知数`m`，由于随着游戏的进行`m`的值也在不断的变化，因此将`m`的值也作为dp表的一个参数。

状态转移方程：`dp[i][m] = sum[i] - max(dp[i + x][x > m ? x : m])`

值得注意的是，其中的`x > m ? x = m`为`m`值的更新。

初始值：上面说到，当`2m`的值大于剩余元素个数时，直接全部取走，因此可以将dp表中`i + 2m > len - 1`的元素dp[i][m]初始化为所有元素的和`sums[i]`。

因此，dp表可以初始化为如下：

```c
	for(int i = len - 1; i >= 0; --i)
		for(int m = len; m > (len - 1 - i) / 2; --m)
			dp[i][m] = sums[i];	
```
dp的核心程序如下：
```c
		for(int i = len - 1; i >=0; --i)
			for(int m = (len - 1 - i) / 2; m > 0; --m)
				for(int x = 1; x <= 2*m; ++x)
					dp[i][m] = std::max(dp[i][m], sums[i] - dp[i + x][x > m ? x : m]);
```
可以以把初始化部分直接在dp的核心程序中：
```c
class Solution {
public:
	int stoneGameII(const vector<int>& piles) {
		int len = piles.size();
		vector<int> sums(len, 0);
		vector <vector<int>> dp(len, vector<int>(len, 0));
		sums[len - 1] = piles[len - 1];
		for (int i = len - 2; i >= 0; --i)
			sums[i] = sums[i + 1] + piles[i];

		for (int i = len - 1; i >= 0; --i)
			for (int m = len - 2; m >= 1; --m) {
				if (i + 2 * m > len - 1) dp[i][m] = sums[i];
				else {
					for (int x = 1; x <= 2 * m; ++x) {
						dp[i][m] = std::max(dp[i][m], sums[i] - dp[i + x][x > m ? x : m]);
					}
				}
			}
		return dp[0][1];
	}
};
```

总结，对于不定大小的变化参数，如上面的`m`值，不妨将其加入dp表作为动态参数。

**10. minimum-falling-path-sum** **

状态转移方程：`dp[i][j] = min(A[i + 1][j + k] + dp[i + 1][j + k])`，其中`k = -1, 0, 1`

初始值：`dp[end][0..end] = 0`

```c
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& A) {
        vector<vector<int>> dp(A.size(), vector<int>(A.size()));
        
        if(A.size() == 1) return A[0][0];
        
        for(int i = 0; i < A.size(); ++i)
            dp[A.size() - 1][i] = 0;
        
        for(int i = A.size() - 2; i >= 0; --i){
            dp[i][0] = std::min(dp[i + 1][0] + A[i + 1][0], dp[i + 1][1] + A[i + 1][1]);
            dp[i][A.size() - 1] = std::min(dp[i + 1][A.size() - 1] + A[i + 1][A.size() - 1], 
                                           dp[i + 1][A.size() - 2] + A[i + 1][A.size() - 2]);
            for(int j = 1; j < A.size() - 1; ++j){
                dp[i][j] = dp[i + 1][j - 1] + A[i + 1][j - 1];
                dp[i][j] = std::min(dp[i][j], dp[i + 1][j + 0] + A[i + 1][j + 0]);
                dp[i][j] = std::min(dp[i][j], dp[i + 1][j + 1] + A[i + 1][j + 1]);
            }
                
        }
        int minimum = INT32_MAX;
        for(int i = 0; i < A.size(); ++i)
            minimum = std::min(minimum, A[0][i] + dp[0][i]);
        return minimum;
    }
};
```
**11. palindromic-substrings** **

对于一个字符串`s`，如果`s[begin] = s[end]`，且子字符串`s[begin+1..end-1]`为回文串，则字符串`s`为回文串。

状态转移方程：`dp[begin][end] = ((s[begin] == s[end]) && dp[begin+1][end-1])`。

```c
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), 0));
        int num = s.size();
        
        for(int i = 0; i < s.size() - 1; ++i){
            dp[i][i] = 1;
            if(s[i] == s[i + 1]){
                dp[i][i+1] = 1;
                num += 1;
            }
        }
        dp[s.size() - 1][s.size() - 1] = 1;
        
        for(int d = 2; d < s.size(); ++d)
            for(int i = 0; i + d < s.size(); ++i){
                if(s[i] == s[i + d] && dp[i + 1][i + d -1]){
                    dp[i][i + d] = 1;
                    num += 1;
                }
            }
        return num;
        
    }
};
```

**12. minimum-cost-for-tickets** **

状态转移方程：`dp[i] = min(cost[k] + dp[next[i][cost[k]]])`，其中k的取值为`0, 1, 2`。

辅助数组：`next[i][3]`保存的是第i天购三种票能用到的最长时间的最一天在days数组中的下标。

初始值：`dp[day.size()] = 0`

```c
class Solution {
public:
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        vector<int> dp(days.size() + 1, 0);
        vector<vector<int>> next(days.size(), vector<int>(3, 0));
        for(int i = 0; i < days.size(); ++i){
            next[i][0] = lower_bound(days.begin() + i, days.end(), days[i] + 1) - days.begin();
            next[i][1] = lower_bound(days.begin() + i, days.end(), days[i] + 7) - days.begin();
            next[i][2] = lower_bound(days.begin() + i, days.end(), days[i] + 30) - days.begin();
        }
        dp[days.size()] = 0;
        for(int i = days.size() - 1; i >= 0; --i){
            dp[i] = costs[0] + dp[next[i][0]];
            dp[i] = max(dp[i], costs[1] + dp[next[i][1]]);
            dp[i] = max(dp[i], costs[2] + dp[next[i][2]]);
        }
            
       return dp[0]; 
    }
};
```
**13. longest-common-subsequence** **
 
 状态转移方程：如果`text1[i] == text2[j]`，则`dp[i][j] = 1 + dp[i + 1][j + 1]`;否则`dp[i][j] = max(dp[i + 1][j], dp[i][j + 1]`。
 
 初始值，dp[text1.size()][text2.size()] = 0
 
 ```c
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        dp[m][n] = 0;
        for(int i = m - 1; i >= 0; --i){
            for(int j = n - 1; j >= 0; --j)
                if(text1[i] == text2[j])
                    dp[i][j] = 1 + dp[i + 1][j + 1];
                else 
                    dp[i][j] = max(dp[i + 1][j], dp[i][j + 1]);
        }
        return dp[0][0];
    }
};
 ```
 
 **14. filling-bookcase-shelves** ****
 
状态转移方程：`dp[i] = min(dp[i], dp[j - 1] + h)`，其中`h = max(h[k]), k = j, j + 1, ..., i`
```c
class Solution 
{
public:
    int minHeightShelves(vector<vector<int>>& books, int shelf_width) 
    {
        if(books.size() == 0) return 0;
        vector<int> dp(books.size() + 1, INT32_MAX);
        dp[0] = 0;
        dp[1] = books[0][1];
        for(int i = 2; i <= books.size(); ++i){
            int h = books[i - 1][1], w = books[i - 1][0];
            dp[i] = dp[i - 1] + books[i - 1][1];
            for(int j = i - 1; j >= 1; --j){
                w += books[j - 1][0];
                if(w > shelf_width) break;
                h = max(h, books[j - 1][1]);
                dp[i] = min(dp[i], dp[j - 1] + h);
            }
        }
        return dp[books.size()];
    }
};
```

**15. longest-string-chain** ***

首先按照长度对所有字符串进行排序，后续会减小复杂度。

对于第`i`的字符串`Si`，长度为`n`，只需要找到长度为`n-1`，且为字符串`Si`的前驱字符串中前驱个数最大的即可。

状态转移方程：`dp[i] = max(1 + dp[k])`，其中k为满足是字符串i的前驱字符串的字符串的下标。

初始值：`dp[0] = 1`;

```c
class Solution {
public:
	int longestStrChain(vector<string>& words) {
		sort(words.begin(), words.end(), [](const string & s1, const string & s2) {
			return s1.size() < s2.size(); });
		vector<int> dp(words.size(), 1);
		int Max_total = 1;
		for (int i = 1; i < words.size(); ++i) {
            if(words[i].size() == words[0].size()) continue;
			int Max = 1;
			for (int j = i - 1; j >= 0; --j) {
				if (words[j].size() == words[i].size()) continue;
				else if (words[j].size() == (words[i].size() - 1)) {
					if (aux(words[i], words[j])) {
						Max = max(Max, 1 + dp[j]);
					}
				}else break;
			}
			dp[i] = Max;
			Max_total = max(Max_total, Max);

		}
		return Max_total;
	}
private:
	bool aux(const string & s1, const string & s2) {
		int cnt = 0;
		int j = 0;
		for (int i = 0; i < s1.size(); ++i) {
			if (s1[i] == s2[j]) j++;
			else cnt++;
		}
		return cnt == 1;
	}

};
```

**16. longest-arithmetic-sequence**

对于元素`A[i]`，它与前`i`个元素的差值`diff`不一定，此时不适合用定长数组或者链表来保存这些差值。

因此这里使用`vector<unordered_map<int, int>>`来保存差值和与之对应的长度。

状态转移方程：如果键值`A[i] - A[k]`存在哈希表`dp[k]`中，`dp[i][A[i] - A[k]] = 1 + dp[k][A[i] - A[k]]`，否则`dp[i][A[i] - A[k]] = 2`。

其中，`A[i] - A[k]`表示第i个元素与第k个元素的差值。

```c
class Solution {
public:
    int longestArithSeqLength(vector<int>& A) {
        vector<unordered_map<int, int>> dp(A.size());
        int Max = 2;
        for(int i = 1; i < A.size(); ++i){
            for(int j = 0; j < i; ++j){
                if(dp[j].find(A[i] - A[j]) != dp[j].end()){
                    dp[i][A[i] - A[j]] = 1 + dp[j][A[i] - A[j]];
                    Max = max(Max, dp[i][A[i] - A[j]]);
                }else{
                    dp[i][A[i] - A[j]] = 2;
                }
            }
        }
        return Max;
    }
};
```

**17. shopping-offers** ****

```c
class Solution {
public:
	using vi = vector<int>;
	int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {
		// Recursive with memory
		dp = vector<int>(pow(7, needs.size()), INT32_MAX);
		return lowestPrice(price, special, needs);
    }
	int lowestPrice(vector<int>& price,vector<vector<int>>& special, vector<int> needs) {
		int pos = 0;
		for (int i = 0; i < needs.size(); ++i) pos = pos * 7 + needs[i];
		if (pos != 0) {
			if (dp[pos] != INT32_MAX) return dp[pos];
			int lowest_special = INT32_MAX;
			for (int i = 0; i < special.size(); ++i) {
				if (notOverflow(special[i], needs)) {
					lowest_special = min(lowest_special, special[i].back() + lowestPrice(price, special, apply(special[i], needs)));
				}
			}
            int lowest_nospecial = 0;
            for(int i = 0; i < needs.size(); ++i){
                lowest_nospecial += price[i] * needs[i];
            }
            
			dp[pos] = min(lowest_special, lowest_nospecial);
			return dp[pos];
		}
		return 0;
	}
	vector<int> apply(const vector<int>& offer, const vector<int>& needs) {
		vector<int> ret(needs);
		for (int i = 0; i < needs.size(); ++i)
			ret[i] = needs[i] - offer[i];
		return ret;
	}
	bool notOverflow(const vector<int> & offer, const vector<int> & needs) {
		for (int i = 0; i < needs.size(); ++i) {
			if (needs[i] < offer[i]) return false;
		}
		return true;
	}
private:
	vector<int> dp;
	int lowest = INT32_MAX;
};
```

**18. maximum-length-of-pair-chain** **

首先按照`start`进行排序。

状态转移方程：`dp[i] = max(1 + dp[j])`，其中`j`满足`dp[j][0] > dp[i][1]`。

```c
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end(), [](const vector<int>& a, const vector<int>& b){
            return a[0] < b[0];
        }); // sort by index0 element
        vector<int> dp(pairs.size(), 1);
        for(int i = pairs.size() - 2; i >= 0; --i){
            int longest_temp = 1;
            for(int j = i + 1; j < pairs.size(); ++j){
                if(pairs[j][0] > pairs[i][1]){
                    longest_temp = max(longest_temp, 1 + dp[j]);
                }
            }
            dp[i] = longest_temp;
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```
**19. unique-paths**

状态转移函数：`dp[i][j] = dp[i + 1][j] + dp[i][j + 1]`

```c
class Solution {
public:
    int uniquePaths(int m, int n) {
        if(m == 1 && n == 1) return 1;
        vector<vector<long long>> dp(m, vector<long long>(n, 0));
        dp[m-1][n-1] = 0;
        for(int i = 0; i < n - 1; ++i) dp[m - 1][i] = 1;
        for(int i = 0; i < m - 1; ++i) dp[i][n - 1] = 1;
        for(int i = m - 2; i >=0; --i){
            for(int j = n - 2; j >=0; --j){
                dp[i][j] = dp[i][j + 1] + dp[i + 1][j];
            }
        }
        return dp[0][0];
    }
};
```

**20. minimum-path-sum**

```c
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(grid);
        dp[m - 1][n - 1] = grid[m - 1][n - 1];
        for(int i = n - 2; i >= 0; --i) dp[m - 1][i] = grid[m - 1][i] + dp[m - 1][i + 1];
        for(int i = m - 2; i >= 0; --i) dp[i][n - 1] = grid[i][n - 1] + dp[i + 1][n - 1];
        for(int i = m - 2; i >= 0; --i){
            for(int j = n - 2; j >= 0; --j){
                dp[i][j] = grid[i][j] + min(dp[i][j + 1], dp[i + 1][j]);   
            }
        }
        return dp[0][0];
    }
};
```

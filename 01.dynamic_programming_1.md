1. Fibnachi

状态转移方程：`f(n) = f(n - 1) + f(n - 2)`

初始值：`f(0) = 0, f(1) = 1`

因此循环从`i = 2`到`i = n - 1`。

空间的优化：由于`f(n)`仅与`f(n-1`和`f(n-2`有关，因此不必用一个完整的dp表来保存子问题的解，这里使用两个变量（`prev`、`curr`）即可。

```c
#include <iostream>
#include <vector>

// Fibonachi
// Dynamic Programming Method
// Time complexity : O(n)
// Space complexity : O(1)

unsigned fib(short n) {
	if (n < 2) return n - 1;
	unsigned prev = 0, curr = 1;
	for (int i = 2; i < n; i++) {
		unsigned sum = prev + curr;
		prev = curr;
		curr = sum;
	}
	return curr;
}

int main(void) {
	for(int i = 1; i <= 10; ++i)
		std::cout << fib(i) << std::endl;
	return 0;
}
```
2. CoinChange

状态转移方程：f(n) = 1 + min(f(n - ci))，ci为第i种硬币的值。

初始值：f(0) = 0（money = 0时，可换硬币的数量为0）

循环从`i = 1`到`i = n`，表示自底向上计算money所能兑换的最少的硬币数。

空间的优化：由于`f(n)`与`f(n-ci)`有关，下面的例子中，`ci`的取值为`1、2、5`因此`f(n)`与`f(n-1)`、`f(n-2)`和`f(n-5)`有关，因此可用长度为5的dp表来保存前5个状态。但这个时候需要频繁的对dp表进行平移，当`ci`有更多的取值时可能会变更为更大的dp表，则用来平移dp表所耗费的时间性能比空间优化带来的性能提升还大了。因此，这里没必要用时间来换空间，一般情况下，时间比空间更重要。

```c
#include <iostream>
#include <algorithm>
#include <vector>

// CoinChange
// Dynamic Programming Method
// Time complexity : O(1)
// Space complexity : O(n)
int CoinChange(const std::vector<int>& coins, unsigned money) {
	std::vector<int> dp(money + 1, money + 1);	// Inital with a large value
	dp[0] = 0;	// 0 -> 0
	for (int i = 0; i < dp.size(); i++) {	// bottom-up
		for (int coin : coins) {
			if (i - coin < 0) continue; // It's important!
			dp[i] = std::min(dp[i], 1 + dp[i - coin]);
		} // for inside
	} // for ouside
	return (dp[money] == money + 1) ? -1 : dp[money];
} // CoinChange

int main(void) {
	std::vector<int> coins = { 1, 2, 5 };
	std::cout << CoinChange(coins, 11) << std::endl;
	return 0;
} // main
```
3. Cut

状态转移方程：f(n) = p[ci] + max(f(n-ci))，其中，ci为一段的长度，p[ci]为对应的价格

初始值：f(0) = 0

循环从`i = 1`到`i = n`结束，表示自底向上计算长度为n的钢条的最佳切割方案。

空间的优化：由于`f(n)`与`f(n-ci)`有关，ci的取值过多，不值得用时间来换空间，因此此处直接用一个长度为`n + 1`的dp表即可。

```c
#include <iostream>
#include <vector>
#include <algorithm>

// Cut
// Dynamic Programming Method
// Time Complexity : O(n)
// Space Complexity : O(n)

int Cut(const std::vector<int> prices, int len, std::vector<int> &answer) {
	std::vector<int> dp(len + 1, - 1);
	dp[0] = 0;
	for (int i = 1; i <= len; ++i) {
		for (int j = 1; j <= 10; ++j) {
			if (i - j < 0) continue;
			if (prices[j - 1] + dp[i - j] > dp[i]) {
				dp[i] = prices[j - 1] + dp[i - j];
				answer[i] = j;
			}
		}
	}
	return dp[len];
}

int main(void) {
	std::vector<int> prices = { 1, 5, 8, 9, 10, 17, 17, 20, 24, 30 };
	std::vector<int> answer(33 + 1, 0);
	std::cout << Cut(prices, 33, answer) << std::endl;
	int len = 33;
	while (len) {
		std::cout << answer[len] << " ";
		len = len - answer[len];
	}
	std::cout << std::endl;
	return 0;
}
```
4. Best Time to Buy and Sell Stock

首先值得明确的一点是买卖均只有一次，也就是说不能买了卖，然后继续买了卖。

最简单直接的方法是遍历所有的起点和终点，得到最大的价格差值即可，时间复杂度为`O(n^2)`

另一种思路是利用动态规划的思想。（例子，`7 1 5 3 6 4`)

先来看看此问题是否有最优子结构，下面将问题进行简单的变换，如果在`7`的时候买入，则大的利润是多少？

如前面所说，利用暴力遍历的时候，需要将`7`后面的所有元素与`7`作差值，最大值就是最大的利润。

如果此时已经知道`1`时买入的最大利润`p[1]`，那么还需要遍历后面的所有元素吗，答案是否定的。

此时只需要将`1`与`7`作差值，得到`7`时买入的最大利润`p[0] = 1 - 7 + p[1]`。

即状态转移方程为：`f(n) = c[n + 1] - c [n] + f(n + 1)`，其中`c[n]`是n时刻的价格。

值得注意的是，如果`f(n+1)`为负数，则上述方程不应该`+f(n+1)`。

```c
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() < 2) return 0;
        int prev = 0, curr = 0;
        int max = 0;
        for(int i = prices.size() - 2; i >= 0; --i){
            curr = prices[i + 1] - prices[i];
            if(prev > 0)
                curr = curr + prev;
            if(curr > max) max = curr;
            prev = curr;
        }
        return max;
    }
};
```
5. climbing-stairs

状态转移方程：f(n) = f(n - 1) + f(n - 2)

这个题实际上就是一个Fibonachi问题。

```c
class Solution {
public:
    int climbStairs(int n) {
        if(n == 0) return 1;
        int prev = 1, curr = 1;
        int sum = 1;
        for(int i = 2; i <= n; ++i){
            sum = prev + curr;
            prev = curr;
            curr = sum;
        }
        return sum;
    }
};
```
6. house-robber
```c

状态转移方程：`f(i) = max(f(i + 2) + ci[i], f(i + 3) + ci[i + 1])`，其中`ci[i]`为第i户的钱财。


class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];
        vector<int> dp(nums.size() + 1, 0);
        dp[nums.size()] = 0;
        dp[nums.size() - 1] = nums[nums.size() - 1];
        dp[nums.size() - 2] = std::max(nums[nums.size() - 1], nums[nums.size() - 2]);
        for(int i = nums.size() - 3; i >= 0; --i){
            dp[i] = std::max(dp[i + 2] + nums[i], dp[i + 3] + nums[i + 1]);
        }
        return dp[0];
    }
};
```

